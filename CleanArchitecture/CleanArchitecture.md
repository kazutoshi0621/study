# まえがき

- アーキテクチャにおいて重要なのはその構造（コンポーネント、クラス、関数、モジュール、レイヤー、サービス、・・・）である。
- 建物はレンガ、コンクリート、木材、スチール、ガラスなどで構成されるが、ソフトウェアはソフトウェアで構成される。大規模なソフトウェアは小規模なソフトウェアから作られ、小規模なソフトウェアはさらに小規模のソフトウェアから作られている。ソフトウェアは本質的に再帰的でフラクタルである。
- アーキテクチャを考える際は、その動作環境（プロセッサの速度、ネットワーク帯域は、メモリ、ストレージなど）の制約を受ける。ソフトウェアは魔法のようなものではなく、物理的な世界で動作している。

# 序文

- 筆者がはじめてコードを書いたのは1964年。そこから半世紀以上にわたり、多種多様なアプリの作成やシステムの構築に携わってきたが、アーキテクチャのルール（プログラムの構成要素をどう組み立てるか）はどれも同じだった。
- この半世紀、ハードウェアは目覚ましい進化を遂げたがソフトウェアの構成は変わっていない。新しい言語やフレームワーク、パラダイム（オブジェクト指向など）が登場したが、コードは今も昔も「順次」「選択」「反復」の組み合わせに過ぎない。書いているコードが変わらないのだから、アーキテクチャのルールも普遍的で変わらない。
- かつての我々はルールを知らなかったが今は違う。半世紀の経験を経て我々はルールをつかんだ。時代を超越した不変のルールたち。それこそが本書のすべてだ。

# ■第Ⅰ部 イントロダクション

- ソフトウェアを動かすのはそれほど難しいことではない。
- ただソフトウェアを正しく作るのは難しい。知識やスキル、思考、洞察力、規律、献身、職人としての情熱、プロになりたいという願望、・・・が必要になる。
- ソフトウェアが正しいと、開発や保守の工数が減り、変更が簡単で迅速になり、欠陥も減り、機能性と柔軟性は最大になる。

## 【第1章】設計とアーキテクチャ

- 「設計」と「アーキテクチャ」に違いはない。
  - 一般的に「アーキテクチャ」は大枠を「設計」は詳細な構造を表す用語として用いられる。
  - しかしソフトウェアの構造は連続的であり、下位の構造と上位の構造とを明確に区別することはできず、最上位から最下位レベルに至るまで構造が再帰的に連なっている。
- 優れたアーキテクチャとは
  - 求められるシステムを構築・保守するための工数が最小になるソフトウェア構造のこと。
  - リリースごとに労力が増えるなら、そのアーキテクチャは優れていない。機能の実装ではなく、崩壊の対応に追われている証拠である。
- 多くの開発者は、クリーンな設計が重要であることがわかっていない。
  - 「あとでクリーンにすればいいから、とりあえず早くリリースしよう！」。開発者たちはそうごまかす。
  - だがあとでクリーンにすることはない。次の機能また次の機能と対応に追われ手が回らない。そして崩壊が始まる。
  - 先ほどの開発者の発言は、崩壊したコードであったとしても短期的には速度が上がる、という背景からだがそれは誤りである。現実には短期的にも長期的にもクリーンなコードを書くほうが常に速い（JasonGormanが実験にて証明）。
- ソフトウェア開発が速く進む唯一の方法は、うまく進むことである。
  - そのためには、優れたアーキテクチャとは何なのかを理解し、アーキテクチャの品質と真剣に向き合う必要がある。

## 【第2章】2つの価値のお話

### 「振る舞い」と「アーキテクチャ」

開発者は、「振る舞い」と「アーキテクチャ」とに責任を負う。が、残念ながら重要度の低い方（振る舞い）の方にフォーカスしがちである。

- 振る舞い
  - 機能要件を満たすように動くこと
  - 振る舞いが要件を満たしていなければ、プログラマはバグを修正する。多くのプログラマはそれが自分たちの仕事だと思っているが、間違いだ。
- アーキテクチャ
  - ソフトウェアの構造のこと
  - 良いアーキテクチャは、ソフトウェアの振る舞いを簡単に変更できる。
  - ソフトウェアである以上、変更は簡単にできるようになっておくべき。変更要件のサイズに対して、コストが不釣り合いにかかってはいけない。
  - 変更しづらい構造の場合、ステークホルダーから見てほとんど同じような要件変更であっても、開発者はジグソーパズルのピースを渡されたような気分になる。パズルは次第に複雑になり、システムの形状と要件の形状とが合わなくなり、新しい要件は前回の要件よりも実装するのが難しくなる。
  - アーキテクチャが特定の形状を前提にしていると新しい要件が適さない可能性が高くなっていく。したがって形状にとらわれないアーキテクチャにしたほうが実用的である。

### どちらが重要か

アーキテクチャのほうが重要である。

「振る舞いは完璧だが変更できないプログラム」と「不完全なふるまいだが変更が簡単なプログラム」ならば後者のほうが価値が高いからだ（なぜなら振る舞いを変えていけるから）。変更できないプログラム、とは、変更のコストがメリットを上回っており事実上変更できなくなっているという意味。多くのシステムでは、一部の機能や設定がその段階に到達している。

###　ビジネスマネージャとの対立について

- ビジネスマネージャは振る舞いが最も重要だと考える（アーキテクチャのことはわからないので）。ただ開発者はこれに賛同してはならない。
- ビジネスマネージャーはアーキテクチャの重要性を評価できない。だからこそソフトウェア開発者が雇われている。アーキテクチャの重要性を強く主張することはしばしばステークホルダーとの対立を生む。しかし優れたソフトウェア開発チームは、真正面からそれに立ち向かい、ステークホルダーたちと対等にひるむことなく口論する。
- ソフトウェア開発者にはソフトウェアに対する責任がある。

アーキテクチャを後回しにすると、システムの開発コストはますます高くなり、システムの一部または全部が変更不能になるだろう。そのことを覚えておいてほしい。もしそのような状態が許されているようなら、ソフトウェア開発チームが懸命に闘わなかったということだ。

# ■第Ⅱ部 構成要素から始めよ：プログラミングパラダイム

- 1938年、AlanTuringがコンピュータプログラミングの基礎を築いた。彼の書いたコードには、ループ、分岐、代入、サブルーチン、スタックなど、我々のよく知るものが使われている。彼の使用していた言語はバイナリ（機械語）だ。
- それからというもの、さまざまなプログラミングの革命が起きている。よく知られた革命は「言語」だ。1940年代後半にアセンブラが登場しプログラマが機械語を書かなくて良くなった。その後、COBOL、C、C++、Java、C#など、絶え間なく新しいプログラミング言語が生み出されている。
- さらに重要な革命は、プログラミングパラダイムの革命だ。パラダイムとは、プログラミングの方法のことであり、どの構造をいつ使うべきかを教えてくれる。このようなパラダイムは3つ存在している。

## 【第3章】パラダイムの概要

- 構造化プログラミング
  - gotoは有害なので、gotoの代わりにif/elseやwhile/forなどを使うべき。
  - 構造化プログラミングは、gotoの使用（直接的な制御の移行）に規律を課すものである。
- オブジェクト指向プログラミング
  - ポリモーフィズムを使う
  - オブジェクト指向プログラミングは、関数ポインタの使用（間接的な制御の移行）に規律を課すものである。
- 関数型プログラミング
  - 変数の値は不変である
  - 関数型プログラミングは、代入に規律を課すものである。

いずれのパラダイムも、教訓（何をすべきではないか）をプログラマに伝えている。なにか新しい能力をプログラマに提供するものではない。

### アーキテクチャにおける、パラダイムの教訓の適用

  - アーキテクチャの境界を越えるために、ポリモーフィズムを使う。
  - データの配置やアクセスに規律を課すために、関数型プログラミングを使う。
  - モジュールの基盤として、構造化プログラミングを使う。

これらの3つが、アーキテクチャの3つの大きな関心事（「コンポーネントの分離」「データ管理」「機能」）に対応していることに注目してほしい。

## 【第4章】構造化プログラミング

Dijkstraは、gotoの代わりに、if/elseやwhile/forなどを使うことで、モジュールを再帰的に小さな単位に分割できることを発見した（「構造化プログラミング」の誕生）。「構造化プログラミング」は、構造化することで検証可能な小さな単位まで分割することに狙いがある。

## 【第5章】オブジェクト指向プログラミング

オブジェクト指向の要素は3つ（カプセル化、継承、ポリモーフィズム）であるが、中でもポリモーフィズムが最も重要。

### カプセル化

OO言語では、プライベートやパブリックの概念を使って「カプセル化」を簡単に利用できる。「カプセル化」により、必要なデータや関数だけが外部から見えるようにできる。

#### C++言語の例

```cpp
// value.h
class CValue {
  public:
    CValue(int x);
    void Increment();
  private:
    int x;
};
```

```cpp
// value.cpp
#include "value.h"

CValue::CValue(int x) {
  this->x = x;
}

CValue::Increment() {
  (this->x)++;
}
```

ただし、残念なこととして、外部にメンバー変数`x`の存在が見えてしまっている。

#### C言語の例

「カプセル化」はOO言語だけのものではない。C言語でもカプセル化は実現できる。

```c
// value.h
struct Value;
struct Value* NewValue(int);
void Increment(struct Value*);
```

```c
// value.c
#include "value.h"

struct Value {
  int x;
};

struct Value* NewValue(int x) {
  struct Value *p = malloc(sizeof(struct Value));
  p->x = x;
  return p;
}

void Increment(struct Value *p) {
  (p->x)++;
}
```

こちらはC++の例と異なり、struct Valueのデータ構造や関数の実装について外部に対して完璧に隠蔽化できている。

### 継承

これもOO言語が登場するはるか前から、C言語のプログラマが手動でやってきた。

#### C言語の例

```c
// main.c
#include "Value.h"
#include "namedValue.h"

int main() {
  struct NamedValue *p = NewNamedValue(0, "hoge");
  Increment((struct Value*)p);    // ここがミソ
}
```

```c
// namedValue.h
struct NamedValue;
struct NamedValue* NewNamedValue(int, char*);
}
```

```c
// namedValue.c
#include "value.h"
#include "namedValue.h"

struct NamedValue {
  struct Value value;             // ここがミソ
  char * name;
};

struct NamedValue* NewNamedValue(int x, char *name) {
  struct NamedValue *p = malloc(sizeof(struct NamedValue));
  p->value->x = x;
  p->name = name;
  return p;
}
```

上のテクニックはOOの登場以前から存在しているが、本物の継承と比べると不便である。OO言語はまったく新しいものを我々に与えてくれたわけではないものの便利になったことは間違いない。

まとめると、カプセル化についてはポイントを獲得できず、継承については半分のポイントしか獲得できていない。これまでのところ、OOのスコアはあまり優れているとは言えない。だが、考慮すべき特性がもうひとつ残されている。

### ポリモーフィズム

ポリモーフィズムとは、ある1つのメソッドの呼び出しに対しオブジェクト毎に異なる動作をすること。

OO言語の登場より前にも、ポリモーフィズムのような振る舞いはあった。

```c
#include<stdio.h>
void echo() {
  while (1) {
    // STDINから読みだして
    int c = getchar();

    // STDOUTに書き込む
    putchar(c);
  }
}
```

`getchar()`や`putchar()`はポリモーフィズムを実現している。
具体的には`STDIN`と`STDOUT`がどのIOデバイスドライバにバインドされているかによって、振る舞いが変わる。

#### 仕組み

`getchar()`の実装は以下のようになっている。

```c
extern struct FILE* STDIN;
int getchar() {
  return STDIN->read();   // STDIN内の関数ポインタを呼び出しているだけ
}
```

また、`FILE`構造体は以下のように宣言されている。

```c
struct FILE {
  void (*open)(char *name, int mode);
  void (*close)();
  int  (*read)();
  void (*write)(char);
  void (*seek)(long index, int mode);
};
```

UNIXは、すべてのIOデバイスドライバに、`open`、`close`、`read`、`write`、`seek`の実装を要求している。また`STDIN`の実体はIOドライバに応じて差し替わるようになっている。

これにより`STDIN->read()`の振る舞いは現在のIOデバイスドライバによって決定されることになり、ポリモーフィズムを実現している。

OO言語のポリモーフィズムも同様である。たとえばC++では、仮想関数を持つクラスの場合、インスタンスの先頭アドレスにvtableという関数テーブルがあり、仮想関数への呼び出しはこのテーブルを経由している。派生クラスのコンストラクタでは、生成したインスタンスのvtableに派生クラスのメソッドをロードする。

まとめると、ポリモーフィズムは関数へのポインタの応用である。OOが何か新しいものを提供しているわけではないが、ポリモーフィズムを安全かつ簡単に利用できるようになった。

OO以前のポリモーフィズムでは、必ずポインタを経由して関数を呼び出すこと、というルールが存在した。そしてルールをやぶってもそれらしく動くため、やっかいなバグになり得た。そう考えるとOO言語によるポリモーフィズムは「強力なパワー」である。

これらを踏まえると、OOは間接的な制御の移行に規律を課すものであると結論づけることができるだろう。

### ポリモーフィズムのパワー
ポリモーフィズムの優れた点は何か？

新しいIOデバイスが登場してもプログラムを一切変えなくて良い点（IOデバイスがプラグインになっている）。

OOならば、プラグインアーキテクチャをどこでも何にでも使うことができる。

### 依存関係逆転

普通に作ると、main関数が上位レベルの関数を呼び出し、それが中間レベルの関数を呼び出し、それが下位レベルの関数を呼び出す。つまりソースコードの依存関係は、制御の流れと同じになってしまう。
関数の呼び出し関係がA→Bだとすると、BがB'に変わるとAも影響を受けてしまう。

ただ、ポリモーフィズムを活用すると、まったく異なることが起きる。
A→Aが要求するインターフェイス→B。BがB'になってもAは変わらない。制御の流れはA→Bだが、依存関係はさっきと逆になっている。これは依存関係逆転と呼ばれ、ソフトウェアアーキテクトに大きな影響を与える。

ポリモーフィズムを使えば、ソースコードの依存関係はどんな場合でも逆転できる。システムにあるすべてのソースコードの依存関係の方向を、制御の流れとは独立して、自由に決定できる。

これにより、データベースとユーザーインターフェイス（UI）をビジネスルールに依存させる（ビジネスルールのプラグインにする）ことができ、ビジネスルールを含むコンポーネントは、UIやデータベースを含むコンポーネントに依存しなくなる。

また、ビジネスルールは、UIやデータベースとは独立してデプロイできる。UIやデータベースに対する変更が、ビジネスルールに影響を与えることはない。

システムにあるモジュールを個別にデプロイできるなら、別々のチームが個別に開発できる。

### まとめ

ソフトウェアアーキテクトにとって、OOとは「ポリモーフィズムにより、システムにあるすべての依存関係を絶対的に制御する能力」である。これにより、アーキテクトは「プラグインアーキテクチャ」を作成できる。

