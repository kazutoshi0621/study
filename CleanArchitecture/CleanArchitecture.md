# まえがき

- アーキテクチャの魅力は構造（コンポーネント、クラス、関数、モジュール、レイヤー、サービス、・・・）である。
- 建物はレンガ、コンクリート、木材、スチール、ガラスなどで構成されるが、ソフトウェアはソフトウェアで構成される。大規模なソフトウェアは小規模なソフトウェアから作られ、小規模なソフトウェアはさらに小規模のソフトウェアから作られている。ソフトウェアは本質的に再帰的でフラクタルである。
- アーキテクチャを考える際は、その動作環境（プロセッサの速度、ネットワーク帯域は、メモリ、ストレージなど）の制約を受ける。ソフトウェアは魔法のようなものではなく、物理的な世界で動作している。

# 序文

- 筆者がはじめてコードを書いたのは1964年。そこから半世紀以上にわたり、アプリの作成、システムの構築二数多く携わってきたがアーキテクチャのルールはどれも同じであった。まったく違うシステムなのにも関わらず。
- この半世紀でハードウェアは目覚ましい進化を遂げた。
- しかしソフトウェアの構成はずっと変わっていない。新しい言語やフレームワーク、パラダイム（オブジェクト指向など）は登場したが、書いているコードは本質的に「順次」「選択」「反復」の組み合わせに過ぎず、これは半世紀以上変わっていない。書いているコードが変わらないのだから、どんな種類のシステムでもアーキテクチャのルール（プログラムの構成要素をどう組み立てるか）も普遍的で変わらない。

- かつての我々はルールを知らなかったため、何度もそのルールを破ってきた。今は違う。半世紀の経験を経て、我々はようやくルールをつかんだ。時代を超越した不変のルールたち。それこそが本書のすべてだ。

# イントロダクション

- ソフトウェアを動かすのはそれほど難しいことではない。
- ただしソフトウェアを正しく作るのは難しい。知識やスキル、思考、洞察力、規律、献身、職人としての情熱、プロになりたいという願望が必要になる。
- ソフトウェアを正しく作ると、開発や保守に必要な人材が減り、変更が簡単で迅速になり、欠陥も減り、労力は最小に抑えられ、機能性と柔軟性は最大になる。

## 設計とアーキテクチャ

- 「設計」と「アーキテクチャ」に違いはない。
  - 一般的に「アーキテクチャ」は大枠を「設計」は詳細な構造を表す用語として用いられる。
  - しかしソフトウェアの構造は連続的であり、下位の構造と上位の構造とを明確に区別することはできない。最上位レベルから最下位レベルまで構造が再帰的に連なっている。
- 優れたアーキテクチャとは
  - 求められるシステムを構築・保守するために必要な人材が最小限であること。
  - リリースごとに労力が増えるなら、そのアーキテクチャは優れていない。機能の開発ではなく、崩壊の対応に追われている証拠である。
- 多くの開発者は、クリーンな設計が重要であることがわかっていない。
  - 「あとでクリーンにすればいいよ。とりあえず早くリリースしよう！」。開発者たちはそうやってごまかす。
  - だがあとでクリーンにすることはない。次の機能また次の機能と対応に追われ手が回らない。そして崩壊が始まる。
  - 先ほどの開発者のごまかしは、崩壊したコードであったとしても短期的には速度が上がる、という考え方にもとづいているのだがそれは誤っている。現実には短期的にも長期的にもクリーンなコードを書くほうが常に速い（JasonGormanが実験で証明済）。
- ソフトウェア開発が速く進む唯一の方法は、うまく進むことである。
  - そのためには、優れたアーキテクチャとは何なのかを理解し、アーキテクチャの品質と真剣に向き合う必要がある。

## 【第2章】2つの価値のお話

- 開発者は、「振る舞い」と「アーキテクチャ」とに責任を負う。
  - が、残念ながら、重要度の低い方（振る舞い）の方にフォーカスしがちだ。

- 振る舞い
  - 機能要件を満たすプログラム動作のこと
  - 書いたコードの振る舞いが要件を満たしていなければ、プログラマはバグを修正する。多くのプログラマは、それが自分たちの仕事だと思っている。これはひどい間違いだ。

- アーキテクチャ
  - ソフトウェアの構造のこと
  - 良いアーキテクチャは、ソフトウェアの振る舞いを簡単に変更できる。
  - ソフトウェアである以上、変更は簡単にできるようになっておくべきだ。変更要件のサイズに対して、コストが不釣り合いにかかってはいけない。
  - 変更しづらい構造の場合、ステークホルダーから見てほとんど同じような要件変更であっても、開発者はジグソーパズルのピースを渡されたような気分になる。パズルは次第に複雑になり、システムの形状と要件の形状とが合わなくなり、新しい要件は前回の要件よりも実装するのが難しくなる。
  - アーキテクチャが特定の形状を前提にしていると新しい要件が適さない可能性が高くなっていく。したがって形状にとらわれないアーキテクチャにしたほうが実用的である。

- アーキテクチャのほうが重要
  - 「振る舞いは完璧だが変更できないプログラム」と「不完全なふるまいだが変更が簡単なプログラム」ならば後者のほうが価値が高い。なぜなら振る舞いを変えていけるからだ。
    - 変更できないプログラム、とは、変更のコストがメリットを上回っており事実上変更できなくなっているという意味。多くのシステムでは、一部の機能や設定がその段階に到達している。

- ビジネスマネージャとの対立
  - ビジネスマネージャは振る舞いが最も重要だと考える（アーキテクチャのことはわからないので）。ただ開発者はこれに賛同してはならない。
  - ビジネスマネージャーはアーキテクチャの重要性を評価できない。だからこそソフトウェア開発者が雇われている。アーキテクチャの重要性を強く主張することはしばしばステークホルダーとの対立を生む。しかし優れたソフトウェア開発チームは、真正面からそれに立ち向かい、ステークホルダーたちと対等にひるむことなく口論する。
  - ソフトウェア開発者にはソフトウェアに対する責任がある。

アーキテクチャを後回しにすると、システムの開発コストはますます高くなり、システムの一部または全部が変更不能になるだろう。そのことを覚えておいてほしい。もしそのような状態が許されているようなら、ソフトウェア開発チームが懸命に闘わなかったということだ。

# 【第Ⅱ部】構成要素から始めよ：プログラミングパラダイム

- 1938年、AlanTuringがコンピュータプログラミングの基礎を築いた。彼の書いたコードには、ループ、分岐、代入、サブルーチン、スタックなど、我々のよく知るものが使われている。彼の使用していた言語はバイナリ（機械語）だ。

- それからというもの、さまざまなプログラミングの革命が起きている。よく知られた革命は「言語」だ。1940年代後半にアセンブラが登場しプログラマが機械語を書かなくて良くなった。その後、COBOL、PL/1、SNOBOL、C、Pascal、C++、Javaなど、絶え間なく新しいプログラミング言語が生み出されている。

- さらに重要な革命がある。それは、プログラミングパラダイムの革命だ。パラダイムとは、プログラミングの方法のことである。パラダイムは、どの構造をいつ使うべきかを教えてくれる。このようなパラダイムは3つ存在している。

## パラダイムの概要

パラダイムは以下の3つである。

- 構造化プログラミング
  - gotoは有害なので、gotoの代わりにif/elseやwhile/forなどを使うべき。
  - 構造化プログラミングは、gotoの使用（直接的な制御の移行）に規律を課すものである。

- オブジェクト指向プログラミング
  - ポリモーフィズムを使う
  - オブジェクト指向プログラミングは、関数ポインタの使用（間接的な制御の移行）に規律を課すものである。

- 関数型プログラミング
  - 変数の値は不変である
  - 関数型プログラミングは、代入に規律を課すものである。

- いずれのパラダイムも、何をすべきではないかをプログラマに伝えている（新しい能力を提供してはいない）。

- パラダイムの教訓は、アーキテクチャの「すべて」において関係している。
  - アーキテクチャの境界を越えるために、ポリモーフィズムを使う。
  - データの配置やアクセスに規律を課すために、関数型プログラミングを使う。
  - モジュールの基盤として、構造化プログラミングを使う。

これらの3つが、アーキテクチャの3つの大きな関心事（「コンポーネントの分離」「データ管理」「機能」）に対応していることに注目してほしい。

# 構造化プログラミング

Dijkstraは、gotoの代わりに、if/elseやwhile/forなどを使うことで、モジュールを再帰的に小さな単位に分割できることを発見した。小さな単位に分割することで、検証可能な単位になる。こうして「構造化プログラミング」が誕生した。

