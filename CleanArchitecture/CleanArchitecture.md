# まえがき

- アーキテクチャにおいて重要なのはその構造（コンポーネント、クラス、関数、モジュール、レイヤー、サービス、・・・）である。
- 建物はレンガ、コンクリート、木材、スチール、ガラスなどで構成されるが、ソフトウェアはソフトウェアで構成される。大規模なソフトウェアは小規模なソフトウェアから作られ、小規模なソフトウェアはさらに小規模のソフトウェアから作られている。ソフトウェアは本質的に再帰的でフラクタルである。
- アーキテクチャを考える際は、その動作環境（プロセッサの速度、ネットワーク帯域は、メモリ、ストレージなど）の制約を受けることを忘れずに。ソフトウェアは魔法ではなく、物理世界で動作している。

# 序文

- 筆者がはじめてコードを書いたのは1964年。そこから半世紀以上にわたり、多種多様なアプリの作成やシステムの構築に携わってきたが、アーキテクチャのルール（プログラムの構成要素をどう組み立てるか）はどれも同じだった。
- この半世紀、ハードウェアは目覚ましい進化を遂げたがソフトウェアの構成は変わっていない。新しい言語やフレームワーク、パラダイム（オブジェクト指向など）は登場したが、コードは今も昔も「順次」「選択」「反復」の組み合わせに過ぎなかった。書いているコードが変わらないのだから、アーキテクチャのルールも普遍的で変わらない。
- かつての我々はルールを知らなかったが今は違う。半世紀の経験を経て我々はルールを学び取った。時代を超越した不変のルールたち。それこそが本書のすべてだ。

# ■第Ⅰ部 イントロダクション

- ソフトウェアを動かすのはそれほど難しいことではない。
- ただソフトウェアを正しく作るのは難しい。知識やスキル、思考、洞察力、規律、献身、職人としての情熱、プロになりたいという願望、・・・が必要になる。
- ソフトウェアが正しく作られていると、開発や保守の工数が減り、変更が簡単で迅速になり、欠陥も減り、機能性と柔軟性は最大になる。

## 【第1章】設計とアーキテクチャ

- 「設計」と「アーキテクチャ」に違いはない。
  - 一般的に「アーキテクチャ」は大枠を「設計」は詳細な構造を表す用語として用いられる。
  - しかしソフトウェアの構造は連続的であり、下位の構造と上位の構造とを明確に区別することはできず、最上位から最下位レベルに至るまで構造が再帰的に連なっている。
- 優れたアーキテクチャとは
  - 求められるシステムを構築・保守するための工数が最小になるソフトウェア構造のこと。
  - リリースごとに労力が増えるなら、そのアーキテクチャは優れていない。機能の実装ではなく、崩壊の対応に追われている証拠である。
- 多くの開発者は、クリーンな設計が重要であることがわかっていない。
  - 「あとでクリーンにすればいいから、とりあえず早くリリースしよう！」。開発者たちはそうごまかす。
  - だがあとでクリーンにすることはない。次の機能また次の機能と対応に追われ手が回らない。そして崩壊が始まる。
  - 先ほどの開発者の発言は、崩壊したコードであったとしても短期的には速度が上がる、という背景からだがそれは誤りである。現実には短期的にも長期的にもクリーンなコードを書くほうが常に速い（JasonGormanが実験にて証明）。
- ソフトウェア開発が速く進む唯一の方法は、うまく進むことである。
  - そのためには、優れたアーキテクチャとは何なのかを理解し、アーキテクチャの品質と真剣に向き合う必要がある。

## 【第2章】2つの価値のお話

### 「振る舞い」と「アーキテクチャ」

開発者は、「振る舞い」と「アーキテクチャ」とに責任を負う。が、残念ながら重要度の低い方（振る舞い）の方にフォーカスしがちである。

- 振る舞い
  - プログラムの動作仕様のこと
  - 振る舞いが要件を満たしていなければ、プログラマはバグを修正する。多くのプログラマはそれが自分たちの仕事だと思っているが、間違いだ。
- アーキテクチャ
  - ソフトウェアの構造のこと
  - 良いアーキテクチャは、ソフトウェアの振る舞いを簡単に変更できる。
  - ソフトウェアである以上、変更は簡単にできるようになっておくべき。変更要件のサイズに対して、コストが不釣り合いにかかってはいけない。
  - 変更しづらい構造の場合、ステークホルダーから見てほとんど同じような要件変更であっても、開発者はジグソーパズルのピースを渡されたような気分になる。パズルは次第に複雑になり、システムの形状と要件の形状とが合わなくなり、新しい要件は前回の要件よりも実装するのが難しくなる。
  - アーキテクチャが特定の形状を前提にしていると新しい要件が適さない可能性が高くなっていく。したがって形状にとらわれないアーキテクチャにしたほうが実用的である。

### どちらが重要か

アーキテクチャのほうが重要である。

「振る舞いは完璧だが変更できないプログラム」と「不完全なふるまいだが変更が簡単なプログラム」ならば後者のほうが価値が高いからだ（なぜなら振る舞いを変えていけるから）。変更できないプログラム、とは、変更のコストがメリットを上回っており事実上変更できなくなっているという意味。多くのシステムでは、一部の機能や設定がその段階に到達している。

### ビジネスマネージャとの対立について

- ビジネスマネージャは振る舞いが最も重要だと考える（アーキテクチャのことはわからないので）。ただ開発者はこれに賛同してはならない。
- ビジネスマネージャーはアーキテクチャの重要性を評価できない。だからこそソフトウェア開発者が雇われている。アーキテクチャの重要性を強く主張することはしばしばステークホルダーとの対立を生む。しかし優れたソフトウェア開発チームは、真正面からそれに立ち向かい、ステークホルダーたちと対等にひるむことなく口論する。
- ソフトウェア開発者にはソフトウェアに対する責任がある。

アーキテクチャを後回しにすると、システムの開発コストはますます高くなり、システムの一部または全部が変更不能になるだろう。そのことを覚えておいてほしい。もしそのような状態が許されているようなら、ソフトウェア開発チームが懸命に闘わなかったということだ。

# ■第Ⅱ部 構成要素から始めよ：プログラミングパラダイム

- 1938年、AlanTuringがコンピュータプログラミングの基礎を築いた。彼の書いたコードには、ループ、分岐、代入、サブルーチン、スタックなど、我々のよく知るものが使われている。彼の使用していた言語はバイナリ（機械語）だ。
- それからというもの、さまざまなプログラミングの革命が起きている。よく知られた革命は「言語」だ。1940年代後半にアセンブラが登場しプログラマが機械語を書かなくて良くなった。その後、COBOL、C、C++、Java、C#など、絶え間なく新しいプログラミング言語が生み出されている。
- さらに重要な革命は、プログラミングパラダイムの革命だ。パラダイムとは、プログラミングの方法のことであり、どの構造をいつ使うべきかを教えてくれる。このようなパラダイムは3つ存在している。

## 【第3章】パラダイムの概要

- 構造化プログラミング
  - gotoは有害なので、gotoの代わりにif/elseやwhile/forなどを使うべき。
  - 構造化プログラミングは、gotoの使用（直接的な制御の移行）に規律を課すものである。
- オブジェクト指向プログラミング
  - ポリモーフィズムを使う
  - オブジェクト指向プログラミングは、関数ポインタの使用（間接的な制御の移行）に規律を課すものである。
- 関数型プログラミング
  - 変数の値は不変である
  - 関数型プログラミングは、代入に規律を課すものである。

いずれのパラダイムも、教訓（何をすべきではないか）をプログラマに伝えている。なにか新しい能力をプログラマに提供するものではない。

### アーキテクチャにおける、パラダイムの教訓の適用

  - アーキテクチャの境界を越えるために、ポリモーフィズムを使う。
  - データの配置やアクセスに規律を課すために、関数型プログラミングを使う。
  - モジュールの基盤として、構造化プログラミングを使う。

これらの3つが、アーキテクチャの3つの大きな関心事（「コンポーネントの分離」「データ管理」「機能」）に対応していることに注目してほしい。

## 【第4章】構造化プログラミング

Dijkstraは、gotoの代わりに、if/elseやwhile/forなどを使うことで、モジュールを再帰的に小さな単位に分割できることを発見した（「構造化プログラミング」の誕生）。「構造化プログラミング」は、構造化することで検証可能な小さな単位まで分割することに狙いがある。

## 【第5章】オブジェクト指向プログラミング

オブジェクト指向の要素は3つ（カプセル化、継承、ポリモーフィズム）であるが、中でもポリモーフィズムが最も重要。

### カプセル化

OO言語では、プライベートやパブリックの概念を使って「カプセル化」を簡単に利用できる。「カプセル化」により、必要なデータや関数だけが外部から見えるようにできる。

#### C++言語の例

```cpp
// value.h
class CValue {
  public:
    CValue(int x);
    void Increment();
  private:
    int x;
};
```

```cpp
// value.cpp
#include "value.h"

CValue::CValue(int x) {
  this->x = x;
}

CValue::Increment() {
  (this->x)++;
}
```

ただし、残念なこととして、外部にメンバー変数`x`の存在が見えてしまっている。

#### C言語の例

「カプセル化」はOO言語だけのものではない。C言語でもカプセル化は実現できる。

```c
// value.h
struct Value;
struct Value* NewValue(int);
void Increment(struct Value*);
```

```c
// value.c
#include "value.h"

struct Value {
  int x;
};

struct Value* NewValue(int x) {
  struct Value *p = malloc(sizeof(struct Value));
  p->x = x;
  return p;
}

void Increment(struct Value *p) {
  (p->x)++;
}
```

こちらはC++の例と異なり、struct Valueのデータ構造や関数の実装について外部に対して完璧に隠蔽化できている。

### 継承

これもOO言語が登場するはるか前から、C言語のプログラマが手動でやってきた。

#### C言語の例

```c
// main.c
#include "Value.h"
#include "namedValue.h"

int main() {
  struct NamedValue *p = NewNamedValue(0, "hoge");
  Increment((struct Value*)p);    // ここがミソ
}
```

```c
// namedValue.h
struct NamedValue;
struct NamedValue* NewNamedValue(int, char*);
}
```

```c
// namedValue.c
#include "value.h"
#include "namedValue.h"

struct NamedValue {
  struct Value value;             // ここがミソ
  char * name;
};

struct NamedValue* NewNamedValue(int x, char *name) {
  struct NamedValue *p = malloc(sizeof(struct NamedValue));
  p->value->x = x;
  p->name = name;
  return p;
}
```

上のテクニックはOOの登場以前から存在しているが、本物の継承と比べると不便である。OO言語はまったく新しいものを我々に与えてくれたわけではないものの便利になったことは間違いない。

まとめると、カプセル化についてはポイントを獲得できず、継承については半分のポイントしか獲得できていない。これまでのところ、OOのスコアはあまり優れているとは言えない。だが、考慮すべき特性がもうひとつ残されている。

### ポリモーフィズム

ポリモーフィズムとは、ある1つのメソッドの呼び出しに対しオブジェクト毎に異なる動作をすること。

OO言語の登場より前にも、ポリモーフィズムのような振る舞いはあった。

```c
#include<stdio.h>
void echo() {
  while (1) {
    // STDINから読みだして
    int c = getchar();

    // STDOUTに書き込む
    putchar(c);
  }
}
```

`getchar()`や`putchar()`はポリモーフィズムを実現している。
具体的には`STDIN`と`STDOUT`がどのIOデバイスドライバにバインドされているかによって、振る舞いが変わる。

#### 仕組み

`getchar()`の実装は以下のようになっている。

```c
extern struct FILE* STDIN;
int getchar() {
  return STDIN->read();   // STDIN内の関数ポインタを呼び出しているだけ
}
```

また、`FILE`構造体は以下のように宣言されている。

```c
struct FILE {
  void (*open)(char *name, int mode);
  void (*close)();
  int  (*read)();
  void (*write)(char);
  void (*seek)(long index, int mode);
};
```

UNIXは、すべてのIOデバイスドライバに、`open`、`close`、`read`、`write`、`seek`の実装を要求している。また`STDIN`の実体はIOドライバに応じて差し替わるようになっている。

これにより`STDIN->read()`の振る舞いは現在のIOデバイスドライバによって決定されることになり、ポリモーフィズムを実現している。

OO言語のポリモーフィズムも同様である。たとえばC++では、仮想関数を持つクラスの場合、インスタンスの先頭アドレスにvtableという関数テーブルがあり、仮想関数への呼び出しはこのテーブルを経由している。派生クラスのコンストラクタでは、生成したインスタンスのvtableに派生クラスのメソッドをロードする。

まとめると、ポリモーフィズムは関数へのポインタの応用である。OOが何か新しいものを提供しているわけではないが、ポリモーフィズムを安全かつ簡単に利用できるようになった。

OO以前のポリモーフィズムでは、必ずポインタを経由して関数を呼び出すこと、というルールが存在した。そしてルールをやぶってもそれらしく動くため、やっかいなバグになり得た。そう考えるとOO言語によるポリモーフィズムは「強力なパワー」である。

これらを踏まえると、OOは間接的な制御の移行に規律を課すものであると結論づけることができるだろう。

### ポリモーフィズムのパワー
ポリモーフィズムの優れた点は何か？

新しいIOデバイスが登場してもプログラムを一切変えなくて良い点（IOデバイスがプラグインになっている）。

OOならば、プラグインアーキテクチャをどこでも何にでも使うことができる。

### 依存関係逆転

普通に作ると、main関数が上位レベルの関数を呼び出し、それが中間レベルの関数を呼び出し、それが下位レベルの関数を呼び出す。つまりソースコードの依存関係は、制御の流れと同じになってしまう。
関数の呼び出し関係がA→Bだとすると、BがB'に変わるとAも影響を受けてしまう。

ただ、ポリモーフィズムを活用すると、まったく異なることが起きる。
A→Aが要求するインターフェイス→B。BがB'になってもAは変わらない。制御の流れはA→Bだが、依存関係はさっきと逆になっている。これは依存関係逆転と呼ばれ、ソフトウェアアーキテクトに大きな影響を与える。

ポリモーフィズムを使えば、ソースコードの依存関係はどんな場合でも逆転できる。システムにあるすべてのソースコードの依存関係の方向を、制御の流れとは独立して、自由に決定できる。

これにより、データベースとユーザーインターフェイス（UI）をビジネスルールに依存させる（ビジネスルールのプラグインにする）ことができ、ビジネスルールを含むコンポーネントは、UIやデータベースを含むコンポーネントに依存しなくなる。

また、ビジネスルールは、UIやデータベースとは独立してデプロイできる。UIやデータベースに対する変更が、ビジネスルールに影響を与えることはない。

システムにあるモジュールを個別にデプロイできるなら、別々のチームが個別に開発できる。

### まとめ

ソフトウェアアーキテクトにとって、OOとは「ポリモーフィズムにより、システムにあるすべての依存関係を絶対的に制御する能力」である。これにより、アーキテクトは「プラグインアーキテクチャ」を作成できる。

## 【第6章】関数型プログラミング

さまざまな意味で、関数型プログラミングの概念はプログラミング以前から存在する。このパラダイムは、1930年代にAlonzoChurchが発明したラムダ計算にもとづいている。

### 整数の二乗

関数型プログラミングを説明するために、いくつかの例を見ていこう。まずは簡単な計算だ。0～2までの整数の二乗を、それぞれ印字するというものだ。

```c
for (int i = 0; i < 3; i++) {
  printf("%d\n", i * i)
}
```

変数`i`は変化していく。

一方で、関数型言語では以下のように実装する。

```clojure
(println                   ; 出力する
  (take 25                 ; 最初の25個の要素を返す
    (map
      (fn [x] (* x x))     ; 入力を受け取って2乗した値を返す匿名関数
      (range)              ; 0から始まる無限個の配列を返す
    )
  )
)
```

関数型言語の変数は変化しない。変数`x`は初期化されているが、そこから変更されることはない。

### 不変性とアーキテクチャ

アーキテクチャの観点からすると、不変性は重要である。なぜなら、マルチプロセスやマルチスレッドにおける、競合、デッドロックなど問題の原因になり得るから。

ある程度の妥協ができれば、不変性は実際に使える。

### 可変性の分離

最も一般的な妥協は、アプリケーションまたはアプリケーションのサービスを適切に構造化し、「可変コンポーネント」と「不変コンポーネント」に分離することである。不変コンポーネントは、可変変数を使わずに、純粋に関数的にタスクを行うものである。

アーキテクトならば、可変コンポーネントからできるだけ多くのコードを追い払い、不変コンポーネントにできるだけ多くの処理を押し込むべきである。

### イベントソーシング

イベントソーシングとは、状態ではなくイベントを保存するやり方のこと。

たとえば残高管理のアプリケーションがあったとして、取引ごとに残高を更新するのではなく、取引のみを保存しておいて、すべての取引を合計することで残高を求めるようなやり方、のこと。ここで重要なのは、取引履歴に対して削除や更新が行われていないということ。その結果、アプリケーションはCRUD(Create/Read/Update/Delete)ではなく、CR(Create/Read)にできる。

この仕組みならば、可変変数(Update/Delete)が要らなくなくなる。

ちなみに、計算量が膨大になる場合は毎回全部計算せずに、ショートカットを用意しても良い。たとえば、毎晩0時に状態を計算して保存しておくことで、0時からの取引だけを計算すれば良くなる。

なお、gitのようなソースコード管理システムもイベントソーシングである（コミットを積み重ねているので）。

### まとめ

- 構造化プログラミングは、直接的な制御の移行に規律を課すものである。
- オブジェクト指向プログラミングは、間接的な制御の移行に規律を課すものである。
- 関数型プログラミングは、代入に規律を課すものである。

これら3つのパラダイムが伝えているのは、我々は何をすべきではないか、である。

半世紀以上、プログラムの本質は変わっていない。「順次」「選択」「反復」と「間接参照」で構成されている。それ以上でも、それ以下でもない。

# ■第Ⅲ部 設計の原則

よくできたソフトウェアシステムは、クリーンなコードを書くことから始まる。そこで登場するのが「SOLID原則」だ。SOLID原則を適用することにより、ソフトウェアは、変更に強く、理解しやすく、流用性が高くなる。

SOLID原則は、モジュールレベルやコンポーネントレベルの構造にも適用できる。

まずSOLID原則を説明したあと、次はそれに対応するコンポーネントの原則を説明する。そのあとに上位レベルのアーキテクチャの原則の話に移る。

SOLID原則の概要

- 単一責任の原則（SRP：Single Responsibility Principle）
  - コンウェイの法則（16章の「開発」を参照）より導かれる原則。各モジュールを変更する理由がたったひとつだけになるようにする。
- オープン・クローズドの原則（OCP：Open-Closed Principle）
  - 新しい機能を実現する場合、既存のコードを変更せずに、新しいコードの追加によって実現できるように設計する。
- リスコフの置換原則（LSP：Liskov Substitution Principle）
  - 抽象クラスで定めた決まりを、継承先の具象クラスが破ってはいけない。
- インターフェイス分離の原則（ISP：InterfaceSegregationPrinciple）
  - 依存が最小限になるよう、インターフェイスを分割する
- 依存関係逆転の原則（DIP：Dependency Inversion Principle）
  - 上位レベル（方針レベル）は、下位レベル（詳細レベル）の実装に依存すべきではない。逆に詳細側が方針側に依存すべきであるという原則。

本書では、SOLID原則を詳細には説明しない。これら原則がアーキテクチャ的にどのような意味を持つのかを中心に説明する。

## 【第7章】SRP：単一責任の原則

モジュールはひとつのアクターに対して責任を負うべき、という原則。

アクターとは、システムを変更するきっかけとなる人たち（ユーザーやステークホルダーなど）のこと。モジュールとは、いくつかの関数やデータをまとめた凝集性のあるものを指す。

次に、SRPを守っていない例を示す。

### SRPを守っていない例（想定外の重複）

従業員管理のシステムについて考える。そのシステムは労働時間の算出と給料の計算ができる。「労働時間計算機能」は人事部が、「給料計算機能」は経理部門が利用している。

この機能を一つのモジュールに押し込めて開発をしてしまった。

「労働時間計算機能」と「給料計算機能」の両方でまったく同じアルゴリズムで所定労働時間を算出していたため、開発者はコードの重複を嫌い、このロジックを共通のメソッドに切り出した。

その後、経理部門からの依頼で「所定労働時間」の計算ロジックに変更を加える必要が出てきた。ただしこの変更は人事部門にとっては不要であった。しかし開発者は「労働時間計算機能」がその共通コードを呼んでいることに気づいておらず、共通コードを変更し、人事部門に迷惑をかけてしまった（デグレ！）。

### 解決策

人事部が使う処理、と、経理部門が使う処理とを、別のモジュールに分けてしまえば良い。ただし単純に分けただけだと、システムを利用するときの入り口まで分かれてしまい、先程のシステムと比較したときに利用しづらいかもしれない。その場合はFacadeパターンを用いて、入り口を1つにまとめてあげれば良い。

### まとめ

SRPは関数やクラスに関する原則だが、コンポーネントレベルやアーキテクチャレベルにも同様の原則は存在する。

- コンポーネント：閉鎖性共通の原則（CCP）
- アーキテクチャ：アーキテクチャの境界を作るための「変更の軸」

これらは、これ以降の章で説明する。

## 【第8章】OCP：オープン・クローズドの原則

「既存のコードを変更せずにソフトウェアを拡張できるようにすべき」という原則（拡張に対して開いていて、修正に対して閉じていること）。OCPはクラスやモジュールレベルに適用してもよいが、コンポーネントレベルに当てはめるととても重要な原則になる。

OCPの目的を達成するために、システムをコンポーネントに分割し、コンポーネントの依存関係を階層構造にする。そして、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないようにする（必要に応じて依存関係を逆転させること）。

## 【第9章】LSP：リスコフの置換原則

1988年にBarbara Liskovが、派生型について以下のように定義した。

> ここで望まれるのは、次に述べるような置換可能な性質である：S型のオブジェクトo1の各々に、対応するT型のオブジェクトo2が1つ存在し、Tを使って定義されたプログラムPに対してo2の代わりにo1を使ってもPの振る舞いが変わらない場合、SはTの派生型であると言える

つまり要約すると

「基底型のオブジェクト」が使われている個所を「派生型のオブジェクト」に置き換えても成り立っていること

この考えは「リスコフの置換原則（LSP）」と呼ばれている。

LSPは当初継承に関する指針と考えられていたが、時間が経つにつれその適用範囲は広がり、今では一般的なインターフェイスと実装に関する原則になっている。

たとえばJava風のインターフェイスだと、それを実装したクラスをいくつも作れるし、Rubyであれば同じメソッドシグネチャを共有するクラスをいくつも作れる。ウェブであれば、同じRESTインターフェイスに応答するサービスをいくつも作れる。このようにさまざまな場面でLSPを適用できる。

LSPはアーキテクチャのレベルにも適用できる（むしろ適用すべき）。原則に少しでも違反してしまうと、アーキテクチャが特別な仕組みだらけになってしまう。

## 【第10章】ISP：インターフェイス分離の原則

あるクラスCがメソッドm1とm2を持っていたときに、コンポーネント1がm1のみを利用し、コンポーネント2がメソッドm2のみを利用する状況を考えてみる。

このときコンポーネント1は実際に使っていないメソッドm2に意図せずに依存してしまっている（なぜなら、m2を変更したときにコンポーネント1も再ビルド＆再デプロイが必要になるので）。

コンポーネント1がm2を使うことが本当にないのであれば、メソッドm1を持つインターフェイス、m2を持つインターフェイスを作り、クラスCはそれを継承。各コンポーネントはそれぞれのインターフェイスに依存させるようにすればよい。こうすればメソッドm2の中身が変更になっても、コンポーネント1は再ビルド＆再デプロイ不要になる。

### インターフェイス分離の原則（ISP）と言語との関係

先ほど述べた内容は、プログラミング言語によって事情が異なっている。

たとえばJavaだと、importやuseやincludeによりソースコードの依存性が生まれ、そのために再コンパイルと再デプロイが必要になってしまう。

一方でRubyやPythonのような動的型付け言語だと実行時に型が推論されるため、再コンパイルや再デプロイを強制するソースコードの依存性は存在しない。

この事実だけを見ると、ISPは言語の問題であり、アーキテクチャの問題ではないと考える人もいるかもしれない。

### インターフェイス分離の原則（ISP）とアーキテクチャとの関係

ただ実際にはアーキテクチャレベルにおいても有力な原則である。

たとえば以下のような依存関係があったとする。

```
[システムS]->[フレームワークF]->[データベースD]
```

システムSがフレームワークFに依存しており、フレームワークFは特定のデータベースDに依存している。

FがDの一部の機能しか使っていない場合、その使っていない機能が変更されたときにもFの再デプロイが必要になってしまう。さらには、Sも再デプロイすることになる。

またDの一部の機能に障害が発生すると、それがFやSの障害の原因になってしまう可能性もある。

### まとめ

必要としないお荷物に依存してはいけない。別途、第13章「コンポーネントの凝集性」で本件を掘り下げる。

## 【第11章】DIP：依存関係逆転の原則

具象ではなく抽象に依存するべきである。たとえばJavaであれば、インターフェイスや抽象クラスのみを含むモジュールをuseやimportやincludeするようにしましょう、ということ。

ただ、JavaのStringクラスのように非常に安定した具象（変更されることをまず考えなくて良いもの）については依存しても構わない。

依存したくないのは、変化しやすい具象だ。開発中のモジュールや、頻繁に変更され続けているモジュールである。

### 抽象は安定している

抽象（インターフェイス）を変更した場合は、対応する具象（振る舞いを実装している側）も影響を受ける。一方で具象を変更しても抽象を変更しなくて済むことも多い。つまり、インターフェイスは実装よりも変化しにくいということになる。

変化しやすい具象がある場合は、そこへの依存を避け、抽象（インターフェイス）に依存するようにすべきである。

つまり、以下のようになる。

- 「変化しやすい具象クラス」を参照しないこと。参照したい場合は抽象化し、そのインターフェイスを参照すること。
- 「変化しやすい具象クラス」を継承しないこと。
- 具象関数をオーバーライドしないこと。オーバーライドしたいときは、元の関数を抽象関数にし、それに対して実装を複数用意すること。

### Factory

ただし前記のルールに従おうとすると、具象オブジェクトを生成する際に困ったことになる。

以下に例を示す。せっかく不安定な`MyServiceImple`を`MyService`として抽象化したのに、オブジェクトを生成するときに不安定な具象クラスに依存してしまっている。

```cpp
/*
+-------------+ 
|MyApplication| -------(使う)-----+
+-------------+                   |
       |                          ↓
       |                   +---------<I>-+
       |                   |  IService   |
       |                   +-------------+
       |                          △
       |                          |
       |                   +-------------+
       +----------(生成)-> | ServiceImpl |
                           +-------------+
*/

// MyApplicationの実装
IService service = new ServiceImple();  // 不安定な具象クラスを参照してしまっている。

```

こんなときはAbstractFactoryパターンを使う。

```cpp
/*
+-------------+ 
|MyApplication| -------(使う)-----+
+-------------+                   |
       |                          |
     (生成)                       |
       ↓                          ↓
+---------<I>-+            +---------<I>-+
|  IService   |            |  IService   |
|   Factory   |            +-------------+
+-------------+                   △
| makeService |                   |
+-------------+                   |
       △                         |
       |                          |          ↑が抽象
====================================================
       |                          |          ↓が具象
       |                          |
+-------------+            +-------------+
|   Service   | --(生成)-> | ServiceImpl |
| FactoryImpl |            +-------------+
+-------------+
| makeService |
+-------------+
*/

// MyApplicationの実装
IServiceFacotry factory = new ServiceFactoryImpl();
IService service = factory.makeService();

```

`MyApplication`が動作としては`ServiceImple`を使っているのにも関わらず、インターフェイスを経由することで、依存性（矢印の向き）が逆向き（下から上）になっているのがポイントである。

このように依存性と処理の流れが逆向きになることから、「依存関係逆転の原則（DIP）」と呼ぶ。

`===`の上が抽象側（いわゆる「方針」）、下が具象側（いわゆる「（実装の）詳細」）である。

よく見ると、`ServiceFactoryImpl`が`ServiceImpl`という具象に依存していたり、`MyApplication`が`ServiceFactoryImple`という具象に依存していて、厳密に言うとDIPに違反している。

しかし現実的にDIP違反を完全に取り除くことはできない。DIPが目的とするところは、不安定な具象に依存するモジュールを減らしたり、不安定なモジュールで構成されたコンポーネントを、他のコンポーネントから分離したりすることである。

### まとめ

本書では、ここからさらに上位レベルのアーキテクチャの原則を扱うことになるが、依存関係逆転の原則（DIP）も何度となく登場する。`===`で区切ったところは、アーキテクチャレベルでは「アーキテクチャの境界」になる。

# ■第Ⅳ部 コンポーネントの原則

SOLID原則がレンガを組み合わせて部屋を作るためにあるとするなら、コンポーネントの原則は部屋を組み合わせて家を作るための原則である。

第Ⅳ部では、コンポーネントとは何かと、それをどのように組み合わせてシステムを作り上げるかを説明する。

## 【第12章】コンポーネント

コンポーネントとは、デプロイ可能な最小単位（*.dllや*.lib、*.exeなど）のことである。適切にコンポーネント分割することで、並行して開発を進められたり、システムの各構成要素をデプロイ可能な状態に保つことが容易になったりする。

## 【第13章】コンポーネントの凝集性

どのようにコンポーネントを決めればよいのか。本章では、それに答える凝集性に着目した原則について述べる。

- 再利用・リリース等価の原則（REP）
- 閉鎖性共通の原則（CCP）
- 全再利用の原則（CRP）

### 再利用・リリース等価の原則（REP）

コンポーネントの再利用性を高めるために、再利用の単位とリリースの単位を同じにすること。

もし再利用の単位の方が大きいなら、その機能を再利用するために、複数のコンポーネントを同時にリリースしないといけないということになる。もしリリースの単位の方が大きいなら、さまざまな機能の更新時にリリースが必要ということになる。

コンポーネントは単一のテーマや目的から成っていないといけない。

この原則に違反すると、コンポーネントの再利用性が低下する。

### 閉鎖性共通の原則（CCP）

同じ理由、同じタイミングで変更されるクラスは1つのコンポーネントにまとめること。変更の理由やタイミングが異なるものは別にすること。

CCPはSOLID原則のS（単一責任の原則）のコンポーネント版になる。単一責任の原則（SRP）は「クラスを変更する理由が複数あるべきではない」という原則だったが、閉鎖性共通の原則（CCP）は「コンポーネントを変更する理由が複数あるべきではない」と説いている。

CCPはSOLID原則のO（オープン・クローズドの原則）とも密接に関連している。

なお、あらゆる変更理由・タイミングを網羅することはできないので、そのシステムにおいて、どういう変更・タイミングが多いのかはよく考える必要がある。つまり「よくある変更」に対してメンテの手間を減らすようにコンポーネントを設計することが重要である。

この原則に違反すると、些細な変更でも大量のコンポーネントを変更しないといけなくなる。

### 全再利用の原則（CRP）

コンポーネントのユーザーに対して、実際には使わないものへの依存を強いないこと。

一緒に用いられることが多いクラスやモジュールは同じコンポーネントにまとめ、そうでないものは別のコンポーネントに分けなければならない。

この原則は、SOLIDのI（インターフェイス分離の原則）のコンポーネント版になる。どちらも、不要なものには依存しないように設計すること、を主張している。

この原則に違反すると、無駄にリリース回数が増える。

### コンポーネントの凝集性のテンション図

3つの原則を同時に満たすことはできない。何を重視するかバランスを取る必要がある。

＃＃＃絵

| 原則 | 狙い |
| --- | --- | --- |
| REP | コンポーネントの再利用性を高める。 |
| CCP | 変更するコンポーネントの数を減らす。 |
| CRP | 不要なリリースの数を減らす。 |

REPとCCPのみを重視すると、リリース回数が無駄に多くなる。

REPとCRPのみを重視すると、変更するコンポーネントの数が膨大になる。

CCPとCRPのみを重視すると、コンポーネントの再利用性が減る。

開発の初期は、REPよりも開発のしやすさを重視しCCPに重きを置く。プロジェクトが進み、他から利用されることが増えてくるにつれ、CCPよりもREPやCRPを重視し始める。

つまり、システムの開発フェーズや成熟度に応じてコンポーネントの構造は変わりうるということ。

## 【第14章】コンポーネントの結合

コンポーネントの関連性を扱う原則について述べる。先ほどと同様、ここでも「開発の利便性」と「論理的な設計」のトレードオフが発生する。

### 非循環依存関係の原則（ADP）

コンポーネントの依存関係が循環してはいけない。

循環の解消の仕方

- 循環参照しないようにコンポーネントを分割・整理する
- 依存関係逆転の原則（DIP）を使い、依存関係を逆転させる

コンポーネントの構造はアプリケーションの成長とともに変化していくため、常に注視しておくこと。

### コンポーネントの設計は変化し続ける

最初にトップダウンで決めておしまい、というものではなく、どんどん変えていく（育てていく）必要がある。

たとえば、モジュールがどんどん増えてくると依存関係を整理・把握する必要が出てくる。

その整理のときに最優先すべきが変動性の分離で、UIとビジネスロジックなどのように、よく変更されるものと変更しないものとを分けることが重要である。そうすることで余計なものを変更しなくて済むようになり、開発効率が上がる。

そして開発が進むにつれ全再利用の原則を使い、ユーザの再利用性を考える。そうなるとまたコンポーネントの構成が変化し、今度は循環参照をするかもしれない。循環参照をしたら解消する。

といったようにコンポーネントの構成は要件の変化や開発フェーズにより変化していくものである。

### 安定依存の原則（SDP）

安定度の高い方向に依存すること。

#### 安定度

多くのコンポーネントから依存されていると、修正量が大きくなるため、変更しづらい（安定している）。また、多くのコンポーネントに依存していると、影響を受けて頻繁に変更が入る（不安定である）。

#### 安定度の指標

コンポーネントの安定度 ＝ 依存されているコンポーネント数 / (依存されているコンポーネント数 + 依存しているコンポーネント数)

コンポーネント図を書くとわかりやすい。依存されているコンポーネント数＝コンポーネントに向かってくる矢印の数。依存しているコンポーネント数＝コンポーネントから出ていく矢印の数。となる。

#### すべてのコンポーネントに高い安定度を求める必要はない

すべてが安定していると、それはすなわち、なにも変更できないということ。安定度の高いコンポーネントと低いコンポーネントが共存している状態が理想。

安定度依存の原則では、安定度の高い方向に依存せよ、とある。
もし安定度の高いコンポーネントから安定度の低いコンポーネントへの依存があった場合は、依存関係逆転の原則を使い、依存関係を逆転させれば良い。

### 安定度・抽象度等価の原則（SAP）

#### 安定度・抽象度等価の原則（SAP）の導入

コンポーネントの抽象度は、その安定度と同程度でなければいけない。

ビジネスロジックのような方針レベルの実装は、多くのコンポーネントから参照される。多くのコンポーネントから参照されているということは、すなわち変更しづらいということなので、間にインターフェイスをもうけて、変更が、参照している他コンポーネントに依存しないように手当するのがよい。

つまり、安定しているコンポーネントは抽象化する。

逆に安定度の低いコンポーネントは抽象度を下げる。そのほうが具体的なコードの変更の手間が減るから。

SOLIDの依存性逆転の原則は、「抽象度の高い方に依存せよ」ということを述べていた。これはコンポーネントにおける、安定度・抽象度等価の原則（SAP）＋安定依存の原則（SDP）、に相当する。

なぜかというと、「安定度・抽象度等価の原則（SAP）」から、安定度が高い＝抽象度が高いということが言え、「安定依存の原則（SDP）」から、安定度が高いものに依存せよ、ということがいえる。これらをあわせると、抽象度の高い方に依存せよ、となるから。

#### 抽象度の計測

コンポーネントの抽象度＝コンポーネント内の抽象クラスの数 ➗ コンポーネント内の総クラス数

抽象クラスが全く無い場合は、Aは0。すべてが抽象クラスの場合は、Aは1となる。

#### 主系列

ここまでで、コンポーネントの安定度と抽象度の算出ができるようになった。

##### 苦痛ゾーン

安定度が大きく、抽象度が低いケース。他から具象クラスを参照されまくっているので、変更する場合は大きな痛みを伴う。→苦痛ゾーンと呼ぶ。

そもそも変動性が低いコンポーネント（Stringクラスなど）は、このゾーンでも問題ない。

苦痛ゾーンにあると問題になるのは変動性の高いコンポーネントである。変動性が高ければ高いほど、苦痛を感じる（より避けるべき）。

##### 無駄ゾーン

逆に、不安定だけど、抽象度が高い場合は無駄である。そのコンポーネントを参照している人がいないのに抽象化しているからだ。

#### 主系列からの距離

安定度・抽象度は機械的に求まるので、実際に算出してみて、異常なコンポーネントを洗い出してみると良い。

# ■第Ⅴ部 アーキテクチャ

## 【第15章】アーキテクチャとは？

アーキテクチャの目的は、システムのライフサイクル（システムの開発、デプロイ、運用、保守）にかかるコストを最小化すること。

なお、アーキテクトは最強のプログラマであるべき。そうでないと優れたアーキテクチャは生み出せない。

### 開発

小規模な開発であれば、がっつりアーキテクチャの構造を決めることがかえって足かせになることもある。一方で大規模な開発であれば、その逆である。

大人数で並行して進める場合はチームを意識したコンポーネント分割になることも往々にしてあるが、このようなチーム体制に依存したアーキテクチャは、システムのライフサイクル（開発、デプロイ、運用、保守）のうち、開発に引っ張られすぎていて、適切ではない。

### デプロイ

アーキテクチャの目的の一つは、簡単なアクションでシステムをデプロイできるようにすることである。

アーキテクチャを検討する場合は、早いうちにデプロイのことも想定しておかないと、あとで地獄を見ることになる。

### 運用

運用時に問題になるのは、アーキテクチャがへぼくて性能がでないとか、ストレージ容量がたらないといったことである。ハードウェアの強化で対応可能なものもあるだろうが、それができない場合もあるので、効率的に動作するアーキテクチャにしておく必要がある。

### 保守

ここが圧倒的に重要。システムのライフサイクルの中でも群を抜いてコストが掛かるから。新機能の実装や不具合修正を行うシーンを想定。

プログラマがやることは、プログラムの設計や実装をまず把握し、影響範囲を確認し、どこにどう手を入れれば最適なのか、戦略を考える。ここに膨大なコストがかかる。

アーキテクチャ次第でここのコストは大幅に下げられる。適切なアーキテクチャであれば、機能追加や修正時に、プログラマを正しい方向へと自然と導いてくれる。

### 選択肢を残しておく

あらゆるソフトウェアは、「方針」と「詳細」に分けられる。「方針」はビジネスロジックを含んでおり価値が高い。一方で「詳細」はビジネスロジックと外部とのIF（WEB、ファイルIO、DB、通信プロトコルなど）。

アーキテクトの目的は、「方針」を慎重に抽出し、「方針」に適したシステムの形状を考え、また「詳細」については決定を後回しにできる（いつ決めてもよいし、そこで自由に選択肢も取れる）ように設計にすることである。

そうすることで、長期間ソフトウェアをソフトに（変更可能に）保つことができるようになる。

## 【第16章】 独立性

優れたアーキテクチャは、以下をサポートしないといけない

- ユースケース
- 運用
- 開発
- デプロイ

### ユースケース

本質的に何をしたいのかを考察しアーキテクチャに反映させる。優れたアーキテクチャは、やりたいこと（ユースケース）そのものをその構造やつけられた名称によって自然に表現できている。

異なる理由で変更されるものを分割。たとえばUIとビジネスロジック（UIを変更する理由と、ビジネスロジックを変更する理由とには相関性がない）。なお、どう分割するかももし選択肢として残しておけるようなアーキテクチャにできるなら、それに越したことはない。

### 運用

システムが必要とする処理能力を発揮できるようにアーキテクチャを構成する（大量のアクセスをさばかないといけないのか、応答性が大事なのか、なんなのか）。

ユースケースを使ってシステムを分割。高い頻度で実行するユースケースにはたとえば高いスループットで実行できるようにしたりもする。なお、どう分割するかももし選択肢として残しておけるようなアーキテクチャにできるなら、それに越したことはない。

### 開発

コンウェイの法則（組織のコミュニケーション構造に依存した設計になる）を適用し、独立性の高い組織や、利害関係の多い組織間が互いに干渉せずに開発できるような構成にしたりして、全体として円滑に開発が進むようにする。

### デプロイ

あれを作ってこれを作って、ディレクトリやファイルを手作業で作成して・・・などとやるのではなく、即時デプロイできるようなアーキテクチャを目指すこと。

適切にコンポーネント分割されていれば、一部だけを差し替えたり、稼働したまま機能を追加したり、柔軟なデプロイもできる。

### 選択肢を残しておく

4つの状況は必然的に変化していくので、最初からバシっと決めきることはできない。だとするとむしろどう転んでも良いように柔軟に作っておくべき。現実的にすべてのケースを想定することはできないが、可能な限り長い期間、多くの選択肢を残しておくようにしておく。

### 重複

重複は陥りがちな罠。

重複したコードがあった場合、それが本質的に同じものであるのか（状況がどうなろうとも今後もずっと同じなのか）、いまたまたま同じであるのか（時間が経てば異なる進化をすることがありうるのか）をよく見極めること。

絶対に、偽の重複を統合しないように。誤った統合をあとで分離するのは非常に難しい。

画面が似ていたり、アルゴリズムが似ていたり、処理が似ていたり・・・など、罠はそこら中に落ちているので、落とし穴に落ちないこと。
