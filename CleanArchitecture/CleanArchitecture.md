# 【第Ⅰ部】イントロダクション

## 【第1章】設計とアーキテクチャ

### 「設計」と「アーキテクチャ」

2つに明確な違いはない。

文脈上、「設計」は細部の構造を、「アーキテクチャ」は大枠の構造を指すことが多い。ただ現実には、構造は連鎖的であり、そこに明確な境目はない。細部の詳細な構造が無いと、その上位の構造も決められない。

### 良いアーキテクチャとは

求められるシステムを構築・メンテするための工数を、最小化できるアーキテクチャのこと

## 【第2章】2つの価値のお話

### ソフトウェア開発者の仕事は2つ

- ①要求を満たす完璧な動作
- ②変更が簡単な構造（こちらのほうが重要）

### なぜか？

②が備わっていれば①を満たしにいくのは容易。また、要件の追加・変更もしやすい。

ソフトウェアは変更できるからこそ「ソフト」である。②がおろそかだと、どんどん構造が複雑化し、針の穴を通す実装になる。。。そのうち変更コストがメリットを上回り、システムの一部または全部が変更不能になる。

### 開発者の存在意義は②にこそある

経営陣は②の重要性が理解できない。ときには②を守るために経営陣と正面から戦うことも必要。決して妥協してはいけない。それが開発者の義務であり、雇われている理由である。

# 【第Ⅱ部】構成要素から始めよ：プログラミングパラダイム

プログラミングパラダイムとは、プログラミングの手法のこと。プログラミングパラダイムは大きく3つある。

- 構造化プログラミング
- オブジェクト指向プログラミング
- 関数型プログラミング

それぞれのパラダイムは、プログラマに「やってはいけないこと」を伝えている（なにか新しい能力を与えているわけではない）。別の言い方をするとプログラマに規律を課している。これらパラダイムは、アーキテクチャのすべてにおいて登場する。

# 構造化プログラミング

当初のプログラムは人間が理解するにはとても複雑なものだった。また驚くほど簡単に間違った。

Dijkstraは、gotoを使わずに、選択（if/else）、反復（whileなど）を使うことでプログラムが構造化できることを発見した。構造化することで、プログラムをテスト可能な単位に再帰的に機能分割していくことができるようになった。

この機能分割の考え方はアーキテクチャにも同様に当てはめることができる。

## オブジェクト指向プログラミング

ポリモーフィズムを使う。

## 関数型プログラミング

変数に値を代入しない（状態を持たない）。

## 
