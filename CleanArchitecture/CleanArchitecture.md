# まえがき

- アーキテクチャにおいて重要なのはその構造（コンポーネント、クラス、関数、モジュール、レイヤー、サービス、・・・）である。
- 建物はレンガ、コンクリート、木材、スチール、ガラスなどで構成されるが、ソフトウェアはソフトウェアで構成される。大規模なソフトウェアは小規模なソフトウェアから作られ、小規模なソフトウェアはさらに小規模のソフトウェアから作られている。ソフトウェアは本質的に再帰的でフラクタルである。
- アーキテクチャを考える際は、その動作環境（プロセッサの速度、ネットワーク帯域は、メモリ、ストレージなど）の制約を受けることを忘れずに。ソフトウェアは魔法ではなく、物理世界で動作している。

# 序文

- 筆者がはじめてコードを書いたのは1964年。そこから半世紀以上にわたり、多種多様なアプリの作成やシステムの構築に携わってきたが、アーキテクチャのルール（プログラムの構成要素をどう組み立てるか）はどれも同じだった。
- この半世紀、ハードウェアは目覚ましい進化を遂げたがソフトウェアの構成は変わっていない。新しい言語やフレームワーク、パラダイム（オブジェクト指向など）は登場したが、コードは今も昔も「順次」「選択」「反復」の組み合わせに過ぎなかった。書いているコードが変わらないのだから、アーキテクチャのルールも普遍的で変わらない。
- かつての我々はルールを知らなかったが今は違う。半世紀の経験を経て我々はルールを学び取った。時代を超越した不変のルールたち。それこそが本書のすべてだ。

# ■第Ⅰ部 イントロダクション

- ソフトウェアを動かすのはそれほど難しいことではない。
- ただソフトウェアを正しく作るのは難しい。知識やスキル、思考、洞察力、規律、献身、職人としての情熱、プロになりたいという願望、・・・が必要になる。
- ソフトウェアが正しく作られていると、開発や保守の工数が減り、変更が簡単で迅速になり、欠陥も減り、機能性と柔軟性は最大になる。

## 【第1章】設計とアーキテクチャ

- 「設計」と「アーキテクチャ」に違いはない。
  - 一般的に「アーキテクチャ」は大枠を「設計」は詳細な構造を表す用語として用いられる。
  - しかしソフトウェアの構造は連続的であり、下位の構造と上位の構造とを明確に区別することはできず、最上位から最下位レベルに至るまで構造が再帰的に連なっている。
- 優れたアーキテクチャとは
  - 求められるシステムを構築・保守するための工数が最小になるソフトウェア構造のこと。
  - リリースごとに労力が増えるなら、そのアーキテクチャは優れていない。機能の実装ではなく、崩壊の対応に追われている証拠である。
- 多くの開発者は、クリーンな設計が重要であることがわかっていない。
  - 「あとでクリーンにすればいいから、とりあえず早くリリースしよう！」。開発者たちはそうごまかす。
  - だがあとでクリーンにすることはない。次の機能また次の機能と対応に追われ手が回らない。そして崩壊が始まる。
  - 先ほどの開発者の発言は、崩壊したコードであったとしても短期的には速度が上がる、という背景からだがそれは誤りである。現実には短期的にも長期的にもクリーンなコードを書くほうが常に速い（JasonGormanが実験にて証明）。
- ソフトウェア開発が速く進む唯一の方法は、うまく進むことである。
  - そのためには、優れたアーキテクチャとは何なのかを理解し、アーキテクチャの品質と真剣に向き合う必要がある。

## 【第2章】2つの価値のお話

### 「振る舞い」と「アーキテクチャ」

開発者は、「振る舞い」と「アーキテクチャ」とに責任を負う。が、残念ながら重要度の低い方（振る舞い）の方にフォーカスしがちである。

- 振る舞い
  - プログラムの動作仕様のこと
  - 振る舞いが要件を満たしていなければ、プログラマはバグを修正する。多くのプログラマはそれが自分たちの仕事だと思っているが、間違いだ。
- アーキテクチャ
  - ソフトウェアの構造のこと
  - 良いアーキテクチャは、ソフトウェアの振る舞いを簡単に変更できる。
  - ソフトウェアである以上、変更は簡単にできるようになっておくべき。変更要件のサイズに対して、コストが不釣り合いにかかってはいけない。
  - 変更しづらい構造の場合、ステークホルダーから見てほとんど同じような要件変更であっても、開発者はジグソーパズルのピースを渡されたような気分になる。パズルは次第に複雑になり、システムの形状と要件の形状とが合わなくなり、新しい要件は前回の要件よりも実装するのが難しくなる。
  - アーキテクチャが特定の形状を前提にしていると新しい要件が適さない可能性が高くなっていく。したがって形状にとらわれないアーキテクチャにしたほうが実用的である。

### どちらが重要か

アーキテクチャのほうが重要である。

「振る舞いは完璧だが変更できないプログラム」と「不完全なふるまいだが変更が簡単なプログラム」ならば後者のほうが価値が高いからだ（なぜなら振る舞いを変えていけるから）。変更できないプログラム、とは、変更のコストがメリットを上回っており事実上変更できなくなっているという意味。多くのシステムでは、一部の機能や設定がその段階に到達している。

### ビジネスマネージャとの対立について

- ビジネスマネージャは振る舞いが最も重要だと考える（アーキテクチャのことはわからないので）。ただ開発者はこれに賛同してはならない。
- ビジネスマネージャーはアーキテクチャの重要性を評価できない。だからこそソフトウェア開発者が雇われている。アーキテクチャの重要性を強く主張することはしばしばステークホルダーとの対立を生む。しかし優れたソフトウェア開発チームは、真正面からそれに立ち向かい、ステークホルダーたちと対等にひるむことなく口論する。
- ソフトウェア開発者にはソフトウェアに対する責任がある。

アーキテクチャを後回しにすると、システムの開発コストはますます高くなり、システムの一部または全部が変更不能になるだろう。そのことを覚えておいてほしい。もしそのような状態が許されているようなら、ソフトウェア開発チームが懸命に闘わなかったということだ。

# ■第Ⅱ部 構成要素から始めよ：プログラミングパラダイム

- 1938年、AlanTuringがコンピュータプログラミングの基礎を築いた。彼の書いたコードには、ループ、分岐、代入、サブルーチン、スタックなど、我々のよく知るものが使われている。彼の使用していた言語はバイナリ（機械語）だ。
- それからというもの、さまざまなプログラミングの革命が起きている。よく知られた革命は「言語」だ。1940年代後半にアセンブラが登場しプログラマが機械語を書かなくて良くなった。その後、COBOL、C、C++、Java、C#など、絶え間なく新しいプログラミング言語が生み出されている。
- さらに重要な革命は、プログラミングパラダイムの革命だ。パラダイムとは、プログラミングの方法のことであり、どの構造をいつ使うべきかを教えてくれる。このようなパラダイムは3つ存在している。

## 【第3章】パラダイムの概要

- 構造化プログラミング
  - gotoは有害なので、gotoの代わりにif/elseやwhile/forなどを使うべき。
  - 構造化プログラミングは、gotoの使用（直接的な制御の移行）に規律を課すものである。
- オブジェクト指向プログラミング
  - ポリモーフィズムを使う
  - オブジェクト指向プログラミングは、関数ポインタの使用（間接的な制御の移行）に規律を課すものである。
- 関数型プログラミング
  - 変数の値は不変である
  - 関数型プログラミングは、代入に規律を課すものである。

いずれのパラダイムも、教訓（何をすべきではないか）をプログラマに伝えている。なにか新しい能力をプログラマに提供するものではない。

### アーキテクチャにおける、パラダイムの教訓の適用

  - アーキテクチャの境界を越えるために、ポリモーフィズムを使う。
  - データの配置やアクセスに規律を課すために、関数型プログラミングを使う。
  - モジュールの基盤として、構造化プログラミングを使う。

これらの3つが、アーキテクチャの3つの大きな関心事（「コンポーネントの分離」「データ管理」「機能」）に対応していることに注目してほしい。

## 【第4章】構造化プログラミング

Dijkstraは、gotoの代わりに、if/elseやwhile/forなどを使うことで、モジュールを再帰的に小さな単位に分割できることを発見した（「構造化プログラミング」の誕生）。「構造化プログラミング」は、構造化することで検証可能な小さな単位まで分割することに狙いがある。

## 【第5章】オブジェクト指向プログラミング

オブジェクト指向の要素は3つ（カプセル化、継承、ポリモーフィズム）であるが、中でもポリモーフィズムが最も重要。

### カプセル化

OO言語では、プライベートやパブリックの概念を使って「カプセル化」を簡単に利用できる。「カプセル化」により、必要なデータや関数だけが外部から見えるようにできる。

#### C++言語の例

```cpp
// value.h
class CValue {
  public:
    CValue(int x);
    void Increment();
  private:
    int x;
};
```

```cpp
// value.cpp
#include "value.h"

CValue::CValue(int x) {
  this->x = x;
}

CValue::Increment() {
  (this->x)++;
}
```

ただし、残念なこととして、外部にメンバー変数`x`の存在が見えてしまっている。

#### C言語の例

「カプセル化」はOO言語だけのものではない。C言語でもカプセル化は実現できる。

```c
// value.h
struct Value;
struct Value* NewValue(int);
void Increment(struct Value*);
```

```c
// value.c
#include "value.h"

struct Value {
  int x;
};

struct Value* NewValue(int x) {
  struct Value *p = malloc(sizeof(struct Value));
  p->x = x;
  return p;
}

void Increment(struct Value *p) {
  (p->x)++;
}
```

こちらはC++の例と異なり、struct Valueのデータ構造や関数の実装について外部に対して完璧に隠蔽化できている。

### 継承

これもOO言語が登場するはるか前から、C言語のプログラマが手動でやってきた。

#### C言語の例

```c
// main.c
#include "Value.h"
#include "namedValue.h"

int main() {
  struct NamedValue *p = NewNamedValue(0, "hoge");
  Increment((struct Value*)p);    // ここがミソ
}
```

```c
// namedValue.h
struct NamedValue;
struct NamedValue* NewNamedValue(int, char*);
}
```

```c
// namedValue.c
#include "value.h"
#include "namedValue.h"

struct NamedValue {
  struct Value value;             // ここがミソ
  char * name;
};

struct NamedValue* NewNamedValue(int x, char *name) {
  struct NamedValue *p = malloc(sizeof(struct NamedValue));
  p->value->x = x;
  p->name = name;
  return p;
}
```

上のテクニックはOOの登場以前から存在しているが、本物の継承と比べると不便である。OO言語はまったく新しいものを我々に与えてくれたわけではないものの便利になったことは間違いない。

まとめると、カプセル化についてはポイントを獲得できず、継承については半分のポイントしか獲得できていない。これまでのところ、OOのスコアはあまり優れているとは言えない。だが、考慮すべき特性がもうひとつ残されている。

### ポリモーフィズム

ポリモーフィズムとは、ある1つのメソッドの呼び出しに対しオブジェクト毎に異なる動作をすること。

OO言語の登場より前にも、ポリモーフィズムのような振る舞いはあった。

```c
#include<stdio.h>
void echo() {
  while (1) {
    // STDINから読みだして
    int c = getchar();

    // STDOUTに書き込む
    putchar(c);
  }
}
```

`getchar()`や`putchar()`はポリモーフィズムを実現している。
具体的には`STDIN`と`STDOUT`がどのIOデバイスドライバにバインドされているかによって、振る舞いが変わる。

#### 仕組み

`getchar()`の実装は以下のようになっている。

```c
extern struct FILE* STDIN;
int getchar() {
  return STDIN->read();   // STDIN内の関数ポインタを呼び出しているだけ
}
```

また、`FILE`構造体は以下のように宣言されている。

```c
struct FILE {
  void (*open)(char *name, int mode);
  void (*close)();
  int  (*read)();
  void (*write)(char);
  void (*seek)(long index, int mode);
};
```

UNIXは、すべてのIOデバイスドライバに、`open`、`close`、`read`、`write`、`seek`の実装を要求している。また`STDIN`の実体はIOドライバに応じて差し替わるようになっている。

これにより`STDIN->read()`の振る舞いは現在のIOデバイスドライバによって決定されることになり、ポリモーフィズムを実現している。

OO言語のポリモーフィズムも同様である。たとえばC++では、仮想関数を持つクラスの場合、インスタンスの先頭アドレスにvtableという関数テーブルがあり、仮想関数への呼び出しはこのテーブルを経由している。派生クラスのコンストラクタでは、生成したインスタンスのvtableに派生クラスのメソッドをロードする。

まとめると、ポリモーフィズムは関数へのポインタの応用である。OOが何か新しいものを提供しているわけではないが、ポリモーフィズムを安全かつ簡単に利用できるようになった。

OO以前のポリモーフィズムでは、必ずポインタを経由して関数を呼び出すこと、というルールが存在した。そしてルールをやぶってもそれらしく動くため、やっかいなバグになり得た。そう考えるとOO言語によるポリモーフィズムは「強力なパワー」である。

これらを踏まえると、OOは間接的な制御の移行に規律を課すものであると結論づけることができるだろう。

### ポリモーフィズムのパワー
ポリモーフィズムの優れた点は何か？

新しいIOデバイスが登場してもプログラムを一切変えなくて良い点（IOデバイスがプラグインになっている）。

OOならば、プラグインアーキテクチャをどこでも何にでも使うことができる。

### 依存関係逆転

普通に作ると、main関数が上位レベルの関数を呼び出し、それが中間レベルの関数を呼び出し、それが下位レベルの関数を呼び出す。つまりソースコードの依存関係は、制御の流れと同じになってしまう。
関数の呼び出し関係がA→Bだとすると、BがB'に変わるとAも影響を受けてしまう。

ただ、ポリモーフィズムを活用すると、まったく異なることが起きる。
A→Aが要求するインターフェイス→B。BがB'になってもAは変わらない。制御の流れはA→Bだが、依存関係はさっきと逆になっている。これは依存関係逆転と呼ばれ、ソフトウェアアーキテクトに大きな影響を与える。

ポリモーフィズムを使えば、ソースコードの依存関係はどんな場合でも逆転できる。システムにあるすべてのソースコードの依存関係の方向を、制御の流れとは独立して、自由に決定できる。

これにより、データベースとユーザーインターフェイス（UI）をビジネスルールに依存させる（ビジネスルールのプラグインにする）ことができ、ビジネスルールを含むコンポーネントは、UIやデータベースを含むコンポーネントに依存しなくなる。

また、ビジネスルールは、UIやデータベースとは独立してデプロイできる。UIやデータベースに対する変更が、ビジネスルールに影響を与えることはない。

システムにあるモジュールを個別にデプロイできるなら、別々のチームが個別に開発できる。

### まとめ

ソフトウェアアーキテクトにとって、OOとは「ポリモーフィズムにより、システムにあるすべての依存関係を絶対的に制御する能力」である。これにより、アーキテクトは「プラグインアーキテクチャ」を作成できる。

## 【第6章】関数型プログラミング

さまざまな意味で、関数型プログラミングの概念はプログラミング以前から存在する。このパラダイムは、1930年代にAlonzoChurchが発明したラムダ計算にもとづいている。

### 整数の二乗

関数型プログラミングを説明するために、いくつかの例を見ていこう。まずは簡単な計算だ。0～2までの整数の二乗を、それぞれ印字するというものだ。

```c
for (int i = 0; i < 3; i++) {
  printf("%d\n", i * i)
}
```

変数`i`は変化していく。

一方で、関数型言語では以下のように実装する。

```clojure
(println                   ; 出力する
  (take 25                 ; 最初の25個の要素を返す
    (map
      (fn [x] (* x x))     ; 入力を受け取って2乗した値を返す匿名関数
      (range)              ; 0から始まる無限個の配列を返す
    )
  )
)
```

関数型言語の変数は変化しない。変数`x`は初期化されているが、そこから変更されることはない。

### 不変性とアーキテクチャ

アーキテクチャの観点からすると、不変性は重要である。なぜなら、マルチプロセスやマルチスレッドにおける、競合、デッドロックなど問題の原因になり得るから。

ある程度の妥協ができれば、不変性は実際に使える。

### 可変性の分離

最も一般的な妥協は、アプリケーションまたはアプリケーションのサービスを適切に構造化し、「可変コンポーネント」と「不変コンポーネント」に分離することである。不変コンポーネントは、可変変数を使わずに、純粋に関数的にタスクを行うものである。

アーキテクトならば、可変コンポーネントからできるだけ多くのコードを追い払い、不変コンポーネントにできるだけ多くの処理を押し込むべきである。

### イベントソーシング

イベントソーシングとは、状態ではなくイベントを保存するやり方のこと。

たとえば残高管理のアプリケーションがあったとして、取引ごとに残高を更新するのではなく、取引のみを保存しておいて、すべての取引を合計することで残高を求めるようなやり方、のこと。ここで重要なのは、取引履歴に対して削除や更新が行われていないということ。その結果、アプリケーションはCRUD(Create/Read/Update/Delete)ではなく、CR(Create/Read)にできる。

この仕組みならば、可変変数(Update/Delete)が要らなくなくなる。

ちなみに、計算量が膨大になる場合は毎回全部計算せずに、ショートカットを用意しても良い。たとえば、毎晩0時に状態を計算して保存しておくことで、0時からの取引だけを計算すれば良くなる。

なお、gitのようなソースコード管理システムもイベントソーシングである（コミットを積み重ねているので）。

### まとめ

- 構造化プログラミングは、直接的な制御の移行に規律を課すものである。
- オブジェクト指向プログラミングは、間接的な制御の移行に規律を課すものである。
- 関数型プログラミングは、代入に規律を課すものである。

これら3つのパラダイムが伝えているのは、我々は何をすべきではないか、である。

半世紀以上、プログラムの本質は変わっていない。「順次」「選択」「反復」と「間接参照」で構成されている。それ以上でも、それ以下でもない。

# ■第Ⅲ部 設計の原則

よくできたソフトウェアシステムは、クリーンなコードを書くことから始まる。そこで登場するのが「SOLID原則」だ。SOLID原則を適用することにより、ソフトウェアは、変更に強く、理解しやすく、流用性が高くなる。

SOLID原則は、モジュールレベルやコンポーネントレベルの構造にも適用できる。

まずSOLID原則を説明したあと、次はそれに対応するコンポーネントの原則を説明する。そのあとに上位レベルのアーキテクチャの原則の話に移る。

SOLID原則の概要

- 単一責任の原則（SRP：Single Responsibility Principle）
  - コンウェイの法則（16章の「開発」を参照）より導かれる原則。各モジュールを変更する理由がたったひとつだけになるようにする。
- オープン・クローズドの原則（OCP：Open-Closed Principle）
  - 新しい機能を実現する場合、既存のコードを変更せずに、新しいコードの追加によって実現できるように設計する。
- リスコフの置換原則（LSP：Liskov Substitution Principle）
  - 抽象クラスで定めた決まりを、継承先の具象クラスが破ってはいけない。
- インターフェイス分離の原則（ISP：InterfaceSegregationPrinciple）
  - 依存が最小限になるよう、インターフェイスを分割する
- 依存関係逆転の原則（DIP：Dependency Inversion Principle）
  - 上位レベル（方針レベル）は、下位レベル（詳細レベル）の実装に依存すべきではない。逆に詳細側が方針側に依存すべきであるという原則。

本書では、SOLID原則を詳細には説明しない。これら原則がアーキテクチャ的にどのような意味を持つのかを中心に説明する。

## 【第7章】SRP：単一責任の原則

モジュールはひとつのアクターに対して責任を負うべき、という原則。

アクターとは、システムを変更するきっかけとなる人たち（ユーザーやステークホルダーなど）のこと。モジュールとは、いくつかの関数やデータをまとめた凝集性のあるものを指す。

次に、SRPを守っていない例を示す。

### SRPを守っていない例（想定外の重複）

従業員管理のシステムについて考える。そのシステムは労働時間の算出と給料の計算ができる。「労働時間計算機能」は人事部が、「給料計算機能」は経理部門が利用している。

この機能を一つのモジュールに押し込めて開発をしてしまった。

「労働時間計算機能」と「給料計算機能」の両方でまったく同じアルゴリズムで所定労働時間を算出していたため、開発者はコードの重複を嫌い、このロジックを共通のメソッドに切り出した。

その後、経理部門からの依頼で「所定労働時間」の計算ロジックに変更を加える必要が出てきた。ただしこの変更は人事部門にとっては不要であった。しかし開発者は「労働時間計算機能」がその共通コードを呼んでいることに気づいておらず、共通コードを変更し、人事部門に迷惑をかけてしまった（デグレ！）。

### 解決策

人事部が使う処理、と、経理部門が使う処理とを、別のモジュールに分けてしまえば良い。ただし単純に分けただけだと、システムを利用するときの入り口まで分かれてしまい、先程のシステムと比較したときに利用しづらいかもしれない。その場合はFacadeパターンを用いて、入り口を1つにまとめてあげれば良い。

### まとめ

SRPは関数やクラスに関する原則だが、コンポーネントレベルやアーキテクチャレベルにも同様の原則は存在する。

- コンポーネント：閉鎖性共通の原則（CCP）
- アーキテクチャ：アーキテクチャの境界を作るための「変更の軸」

これらは、これ以降の章で説明する。

## 【第8章】OCP：オープン・クローズドの原則

「既存のコードを変更せずにソフトウェアを拡張できるようにすべき」という原則（拡張に対して開いていて、修正に対して閉じていること）。OCPはクラスやモジュールレベルに適用してもよいが、コンポーネントレベルに当てはめるととても重要な原則になる。

OCPの目的を達成するために、システムをコンポーネントに分割し、コンポーネントの依存関係を階層構造にする。そして、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないようにする（必要に応じて依存関係を逆転させること）。

## 【第9章】LSP：リスコフの置換原則

1988年にBarbara Liskovが、派生型について以下のように定義した。

> ここで望まれるのは、次に述べるような置換可能な性質である：S型のオブジェクトo1の各々に、対応するT型のオブジェクトo2が1つ存在し、Tを使って定義されたプログラムPに対してo2の代わりにo1を使ってもPの振る舞いが変わらない場合、SはTの派生型であると言える

つまり要約すると

「基底型のオブジェクト」が使われている個所を「派生型のオブジェクト」に置き換えても成り立っていること

この考えは「リスコフの置換原則（LSP）」と呼ばれている。

LSPは当初継承に関する指針と考えられていたが、時間が経つにつれその適用範囲は広がり、今では一般的なインターフェイスと実装に関する原則になっている。

たとえばJava風のインターフェイスだと、それを実装したクラスをいくつも作れるし、Rubyであれば同じメソッドシグネチャを共有するクラスをいくつも作れる。ウェブであれば、同じRESTインターフェイスに応答するサービスをいくつも作れる。このようにさまざまな場面でLSPを適用できる。

LSPはアーキテクチャのレベルにも適用できる（むしろ適用すべき）。原則に少しでも違反してしまうと、アーキテクチャが特別な仕組みだらけになってしまう。

## 【第10章】ISP：インターフェイス分離の原則

あるクラスCがメソッドm1とm2を持っていたときに、コンポーネント1がm1のみを利用し、コンポーネント2がメソッドm2のみを利用する状況を考えてみる。

このときコンポーネント1は実際に使っていないメソッドm2に意図せずに依存してしまっている（なぜなら、m2を変更したときにコンポーネント1も再ビルド＆再デプロイが必要になるので）。

コンポーネント1がm2を使うことが本当にないのであれば、メソッドm1を持つインターフェイス、m2を持つインターフェイスを作り、クラスCはそれを継承。各コンポーネントはそれぞれのインターフェイスに依存させるようにすればよい。こうすればメソッドm2の中身が変更になっても、コンポーネント1は再ビルド＆再デプロイ不要になる。

### インターフェイス分離の原則（ISP）と言語との関係

先ほど述べた内容は、プログラミング言語によって事情が異なっている。

たとえばJavaだと、importやuseやincludeによりソースコードの依存性が生まれ、そのために再コンパイルと再デプロイが必要になってしまう。

一方でRubyやPythonのような動的型付け言語だと実行時に型が推論されるため、再コンパイルや再デプロイを強制するソースコードの依存性は存在しない。

この事実だけを見ると、ISPは言語の問題であり、アーキテクチャの問題ではないと考える人もいるかもしれない。

### インターフェイス分離の原則（ISP）とアーキテクチャとの関係

ただ実際にはアーキテクチャレベルにおいても有力な原則である。

たとえば以下のような依存関係があったとする。

```
[システムS]->[フレームワークF]->[データベースD]
```

システムSがフレームワークFに依存しており、フレームワークFは特定のデータベースDに依存している。

FがDの一部の機能しか使っていない場合、その使っていない機能が変更されたときにもFの再デプロイが必要になってしまう。さらには、Sも再デプロイすることになる。

またDの一部の機能に障害が発生すると、それがFやSの障害の原因になってしまう可能性もある。

### まとめ

必要としないお荷物に依存してはいけない。別途、第13章「コンポーネントの凝集性」で本件を掘り下げる。